{"version":3,"sources":["../src/parser.ts","../src/renderer.ts","../src/index.ts"],"sourcesContent":["export interface TreeNode {\n  name: string\n  comment?: string\n  isFolder: boolean\n  depth: number\n  children: TreeNode[]\n}\n\ninterface ParsedLine {\n  depth: number\n  name: string\n  comment?: string\n  isFolder: boolean\n}\n\nfunction parseLine(line: string): ParsedLine | null {\n  if (!line.trim()) return null\n\n  // Find the position of the branch character (├ or └) to determine depth\n  // Each indentation level is 4 characters wide\n  const INDENT_WIDTH = 4\n\n  // Find the last branch character (├ or └)\n  let branchPos = -1\n  for (let i = 0; i < line.length; i++) {\n    if (line[i] === '├' || line[i] === '└') {\n      branchPos = i\n    }\n  }\n\n  let depth: number\n  let rest: string\n\n  if (branchPos >= 0) {\n    // Depth is based on the position of the branch character\n    depth = Math.floor(branchPos / INDENT_WIDTH) + 1\n\n    // Find where the name starts (after ├── or └── or ├─ or └─)\n    const afterBranch = line.slice(branchPos)\n    const nameMatch = afterBranch.match(/^[├└]─+\\s*/)\n    if (nameMatch) {\n      rest = afterBranch.slice(nameMatch[0].length)\n    } else {\n      rest = afterBranch.slice(1).trim()\n    }\n  } else {\n    // No branch character - this is a root node\n    depth = 0\n    rest = line.trim()\n  }\n\n  // Split name and comment\n  // Comments start with # or //\n  let name: string\n  let comment: string | undefined\n\n  const commentMatch = rest.match(/^(.+?)\\s+(#|\\/\\/)(.*)$/)\n  if (commentMatch) {\n    name = commentMatch[1].trim()\n    comment = commentMatch[3].trim()\n  } else {\n    name = rest.trim()\n  }\n\n  if (!name) return null\n\n  // Convert ASCII arrows to Unicode\n  name = name.replace(/->/g, '→').replace(/<-/g, '←')\n  if (comment) {\n    comment = comment.replace(/->/g, '→').replace(/<-/g, '←')\n  }\n\n  const isFolder = name.endsWith('/')\n\n  return {\n    depth,\n    name,\n    comment,\n    isFolder,\n  }\n}\n\nexport function parseTree(source: string): TreeNode[] {\n  const lines = source.split('\\n')\n  const parsedLines: ParsedLine[] = []\n\n  for (const line of lines) {\n    const parsed = parseLine(line)\n    if (parsed) {\n      parsedLines.push(parsed)\n    }\n  }\n\n  // Build tree structure\n  const roots: TreeNode[] = []\n  const stack: { node: TreeNode; depth: number }[] = []\n\n  for (const line of parsedLines) {\n    const node: TreeNode = {\n      name: line.name,\n      comment: line.comment,\n      isFolder: line.isFolder,\n      depth: line.depth,\n      children: [],\n    }\n\n    // Find parent\n    while (stack.length > 0 && stack[stack.length - 1].depth >= line.depth) {\n      stack.pop()\n    }\n\n    if (stack.length === 0) {\n      roots.push(node)\n    } else {\n      stack[stack.length - 1].node.children.push(node)\n    }\n\n    stack.push({ node, depth: line.depth })\n  }\n\n  return roots\n}\n","import type { TreeNode } from './parser'\n\nfunction escapeHtml(text: string): string {\n  return text\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n}\n\ninterface FlattenedRow {\n  depth: number\n  name: string\n  isFolder: boolean\n  comment?: string\n  // For each depth level, whether to show a vertical line (true) or empty space (false)\n  verticalLines: boolean[]\n  isLast: boolean\n}\n\nfunction flattenTree(\n  nodes: TreeNode[],\n  depth: number = 0,\n  verticalLines: boolean[] = []\n): FlattenedRow[] {\n  const rows: FlattenedRow[] = []\n\n  nodes.forEach((node, index) => {\n    const isLast = index === nodes.length - 1\n\n    rows.push({\n      depth,\n      name: node.name,\n      isFolder: node.isFolder,\n      comment: node.comment,\n      verticalLines: [...verticalLines],\n      isLast,\n    })\n\n    // Recurse into children\n    if (node.children.length > 0) {\n      // For children, add vertical line if this node is not last\n      const childRows = flattenTree(\n        node.children,\n        depth + 1,\n        [...verticalLines, !isLast]\n      )\n      rows.push(...childRows)\n    }\n  })\n\n  return rows\n}\n\nexport function renderTreeHtml(nodes: TreeNode[]): string {\n  const rows = flattenTree(nodes)\n\n  const tableRows = rows.map(row => {\n    const nameHtml = row.isFolder\n      ? `<strong>${escapeHtml(row.name)}</strong>`\n      : escapeHtml(row.name)\n\n    const commentHtml = row.comment\n      ? `<span class=\"tree-comment\">${escapeHtml(row.comment)}</span>`\n      : ''\n\n    // Build the indentation with CSS lines\n    let indentHtml = ''\n\n    // Add vertical line segments for each depth level\n    for (let i = 0; i < row.verticalLines.length; i++) {\n      const hasLine = row.verticalLines[i]\n      indentHtml += `<span class=\"tree-indent${hasLine ? ' tree-vline' : ''}\"></span>`\n    }\n\n    // Add the branch connector for non-root nodes\n    if (row.depth > 0) {\n      const branchClass = row.isLast ? 'tree-corner' : 'tree-branch'\n      indentHtml += `<span class=\"tree-indent ${branchClass}\"></span>`\n    }\n\n    return `\n      <tr>\n        <td class=\"tree-structure\">${indentHtml}<span class=\"tree-name\">${nameHtml}</span></td>\n        <td class=\"tree-comment-cell\">${commentHtml}</td>\n      </tr>\n    `\n  }).join('')\n\n  return `\n    <div class=\"tree-container\">\n      <table class=\"tree-table\">\n        <tbody>\n          ${tableRows}\n        </tbody>\n      </table>\n    </div>\n  `\n}\n","export { parseTree, TreeNode } from './parser'\nexport { renderTreeHtml } from './renderer'\n\nimport { parseTree } from './parser'\nimport { renderTreeHtml } from './renderer'\n\n/**\n * Parse ASCII tree structure and render as HTML table.\n * @param source - ASCII tree structure string\n * @returns HTML string with semantic class names for styling\n */\nexport function renderTree(source: string): string {\n  const tree = parseTree(source)\n  return renderTreeHtml(tree)\n}\n"],"mappings":"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","names":[]}